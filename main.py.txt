import os
import requests
import time
import logging
import re
from telegram import Update
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, MessageHandler, filters
from keep_alive import keep_alive  # ××—×‘×¨ ××•×ª× ×• ×œ×§×•×‘×¥ ×©××©××™×¨ ××ª ×”×‘×•×˜ ×¢×¨

# ==========================================
# âš™ï¸ ×”×’×“×¨×•×ª (Settings)
# ==========================================

# ×ª×™×§× ×ª×™ ×œ×š ××ª ×”-ID ×œ×¤×•×¨××˜ ×”×ª×§×™×Ÿ ×©×œ ×¢×¨×•×¥ ×˜×œ×’×¨× (×—×™×™×‘ ×œ×”×ª×—×™×œ ×‘ -100)
# ×× ×–×” ×œ× ×¢×•×‘×“, × ×¡×” ×œ×”×—×–×™×¨ ×œ××¡×¤×¨ ×”××§×•×¨×™ ×œ×œ× ×”-100 ×‘×”×ª×—×œ×”
TARGET_CHANNEL_ID = -1001687054059

PROMPT_FILE_NAME = "prompt_realtor.txt"
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')

# ×‘×“×™×§×” ×©×”××¤×ª×—×•×ª ×§×™×™××™×
if not GEMINI_API_KEY or not TELEGRAM_BOT_TOKEN:
    raise SystemExit("âŒ ×©×’×™××”: ××¤×ª×—×•×ª (Secrets) ×—×¡×¨×™×! × × ×œ×”×’×“×™×¨ GEMINI_API_KEY ×•-TELEGRAM_BOT_TOKEN.")

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# ×˜×¢×™× ×ª ×§×•×‘×¥ ×”×”×•×¨××•×ª
try:
    with open(PROMPT_FILE_NAME, 'r', encoding='utf-8') as file:
        SYSTEM_PROMPT = file.read()
except FileNotFoundError:
    SYSTEM_PROMPT = "You are a helpful real estate assistant."
    print(f"âš ï¸ ×”×¢×¨×”: ×”×§×•×‘×¥ {PROMPT_FILE_NAME} ×œ× × ××¦×. ××©×ª××© ×‘×”×•×¨××•×ª ×‘×¨×™×¨×ª ××—×“×œ.")

chats_history = {}

# ==========================================
# ğŸ§  ×¤×•× ×§×¦×™×•×ª ×œ×™×‘×” (Core Logic)
# ==========================================

def send_to_google_direct(history_text, user_text):
    """
    ×©×•×œ×— ×‘×§×©×” ×œ×’×•×’×œ ×“×¨×š HTTP ×™×©×™×¨ (×¢×•×§×£ ×‘××’×™× ×©×œ ×¡×¤×¨×™×•×ª).
    ×× ×¡×” ××•×“×œ×™× ×©×•× ×™× ×œ×¤×™ ×¡×“×¨ ×¢×“×™×¤×•×ª.
    """
    # ×¡×“×¨ ×”× ×™×¡×™×•× ×•×ª: ×”×›×™ ×—×“×© -> ×œ×™×™×˜ -> ×¨×’×™×œ
    models_to_try = [
        "gemini-2.5-flash", 
        "gemini-2.0-flash-lite-preview-02-05", 
        "gemini-2.0-flash",
        "gemini-1.5-flash" 
    ]
    
    headers = {'Content-Type': 'application/json'}
    payload = {
        "contents": [{
            "parts": [{"text": f"{SYSTEM_PROMPT}\n\n×”×™×¡×˜×•×¨×™×”:\n{history_text}\n×œ×§×•×—: {user_text}\n×× ×™:"}]
        }]
    }

    for model_name in models_to_try:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={GEMINI_API_KEY}"
        try:
            response = requests.post(url, json=payload, headers=headers)
            
            # ×”×¦×œ×—×” (200)
            if response.status_code == 200:
                return response.json()['candidates'][0]['content']['parts'][0]['text']
            
            # ×¢×•××¡ (429) - × ×—×›×” ×§×¦×ª ×•× × ×¡×” ××ª ×”××•×“×œ ×”×‘×
            elif response.status_code == 429:
                time.sleep(1) 
                continue
                
            # ×©×’×™××•×ª ××—×¨×•×ª (×›××• 404 ××•×“×œ ×œ× × ××¦×) - ×¤×©×•×˜ ×××©×™×›×™× ×”×‘×
            else:
                continue

        except Exception as e:
            print(f"Error connecting to {model_name}: {e}")
            continue
            
    return None # ×× ×”×›×œ × ×›×©×œ

async def check_for_lead(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ ×‘×•×“×§ ×× ×™×© ×˜×œ×¤×•×Ÿ ×•×©×•×œ×— ×œ×¢×¨×•×¥ """
    user_text = update.message.text
    user_name = update.effective_user.first_name
    username = update.effective_user.username
    
    # ×–×™×”×•×™ ××¡×¤×¨ ×˜×œ×¤×•×Ÿ (Regex)
    phone_pattern = re.compile(r'\b0?5[0-9]{8}\b') 
    clean_text = user_text.replace("-", "").replace(" ", "")
    
    if phone_pattern.search(clean_text):
        print("ğŸ“ ×–×•×”×” ×œ×™×“! ×©×•×œ×— ×œ×¢×¨×•×¥...")
        
        alert_text = (
            f"ğŸ”” <b>×œ×™×“ ×—×“×© ×”×ª×§×‘×œ!</b>\n"
            f"â–â–â–â–â–â–â–\n"
            f"ğŸ‘¤ <b>×©×:</b> {user_name}\n"
            f"ğŸ”— <b>×™×•×–×¨:</b> @{username if username else '××™×Ÿ'}\n"
            f"ğŸ“± <b>×”×•×“×¢×”:</b>\n"
            f"<i>{user_text}</i>"
        )
        try:
            await context.bot.send_message(chat_id=TARGET_CHANNEL_ID, text=alert_text, parse_mode='HTML')
            print(f"âœ… × ×©×œ×— ×‘×”×¦×œ×—×” ×œ×¢×¨×•×¥ {TARGET_CHANNEL_ID}")
        except Exception as e:
            print(f"âŒ ×©×’×™××” ×‘×©×œ×™×—×” ×œ×¢×¨×•×¥: {e}")
            print("ğŸ’¡ ×˜×™×¤: ×•×•×“× ×©×”×‘×•×˜ ×”×•× Admin ×‘×¢×¨×•×¥, ×•×©×”-ID ××ª×—×™×œ ×‘ -100")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text
    user_id = update.effective_user.id
    
    # 1. ×‘×“×™×§×ª ×œ×™×“
    await check_for_lead(update, context)

    # 2. × ×™×”×•×œ ×©×™×—×”
    if user_id not in chats_history:
        chats_history[user_id] = []

    # ×‘× ×™×™×ª ×”×™×¡×˜×•×¨×™×” (6 ×”×•×“×¢×•×ª ××—×¨×•× ×•×ª)
    history_txt = ""
    for msg in chats_history[user_id][-6:]:
        history_txt += f"{msg['role']}: {msg['text']}\n"

    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action='typing')
    
    # ×©×œ×™×—×” ×œ×’×•×’×œ
    bot_answer = send_to_google_direct(history_txt, user_text)
    
    if not bot_answer:
        bot_answer = "××¦×˜×¢×¨, ×™×© ×›×¨×’×¢ ×¢×•××¡ ×—×¨×™×’ ×‘××¢×¨×›×ª. ×× × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×“×§×”."

    # ×©××™×¨×” ×•×¢×“×›×•×Ÿ
    chats_history[user_id].append({"role": "×œ×§×•×—", "text": user_text})
    chats_history[user_id].append({"role": "×× ×™", "text": bot_answer})
    
    await context.bot.send_message(chat_id=update.effective_chat.id, text=bot_answer)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chats_history[update.effective_user.id] = []
    welcome_msg = "×©×œ×•×! ×× ×™ ×”×¢×•×–×¨×ª ×”××™×©×™×ª ×œ××¦×™××ª ×“×™×¨×”. ××™×š ×× ×™ ×™×›×•×œ×” ×œ×¢×–×•×¨ ×œ×š ×”×™×•×?"
    await context.bot.send_message(chat_id=update.effective_chat.id, text=welcome_msg)

if __name__ == '__main__':
    # === ×©×œ×‘ ×§×¨×™×˜×™: × ×™×§×•×™ ×”-Webhook ×›×“×™ ×œ×× ×•×¢ ×”×ª× ×’×©×•×™×•×ª ===
    print("ğŸ§¹ ×× ×§×” ×—×™×‘×•×¨×™× ×™×©× ×™× ××•×œ ×˜×œ×’×¨×...")
    try:
        requests.get(f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/deleteWebhook?drop_pending_updates=True")
        print("âœ… ×”× ×™×§×•×™ ×”×•×©×œ×.")
    except Exception as e:
        print(f"âš ï¸ ×©×’×™××” ×‘× ×™×§×•×™ (×œ× ×§×¨×™×˜×™): {e}")

    # === ×”×¤×¢×œ×ª ×©×¨×ª ×”-Keep Alive (×¢×•×‘×“ ×‘-Replit ×•×‘-Render) ===
    keep_alive()

    # === ×”×¤×¢×œ×ª ×”×‘×•×˜ ===
    application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()
    application.add_handler(CommandHandler('start', start))
    application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_message))
    
    print(f"ğŸš€ ×”×‘×•×˜ ×¨×¥! (××–×”×” ×¢×¨×•×¥: {TARGET_CHANNEL_ID})")
    application.run_polling()